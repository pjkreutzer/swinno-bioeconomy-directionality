---
title: Shades of Green
subtitle: Direction of the Swedish Forest Innovation System 1970-2020
author: Jonas Kreutzer
date: last-modified
abstract: |
    
csl: https://zotero.org/styles/apa?source=1
bibliography: [../../swinno-shades-green.bib]

format: revealjs
# format:
#   revealjs:
#     theme: [../assets/revealme.scss]
#     transition: none
#     title-slide-attributes:
#       data-background-image: '../assets/ground-fog-valley-black-forest-sunset.jpg'
#       data-background-size: fit
#       data-background-opacity: '0.3'
#     embed-resources: true


execute:
    freeze: auto
    echo: false
jupyter: python3
---

```{python}

from IPython.display import display, Markdown

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns
import altair as alt

from src.swinno_helpers import connect_swinno_db

swinno_db = connect_swinno_db()

# set all text on plots to be monospace with rcParams
plt.rcParams["font.family"] = "monospace"


sns.set_theme(style="whitegrid")


def format_table(df):
    # create a Styler object and set the wrapping style
    styler = df.style.set_properties(**{"width": "50em", "text-wrap": "break-word"})

    return styler


def plot_counts(
    df1, df2, category_col, y, show_legend=True, legend_cols=None, y_label="Count"
):
    categories = df1[category_col].astype(str).unique()
    categories.sort()

    legend_ncols = len(categories) if legend_cols is None else legend_cols

    colors = sns.color_palette("colorblind", len(categories))
    palette = dict(zip(categories, colors))

    fig, axes = plt.subplots(
        ncols=1, nrows=2, sharex=False, sharey=True, layout="tight"
    )

    marker_size = 100
    df1 = df1.sort_values(by=category_col)
    df2 = df2.sort_values(by=category_col)

    sns.scatterplot(
        x=df1.index,
        y=y,
        hue=category_col,
        data=df1,
        ax=axes[0],
        palette=palette,
        s=marker_size,
    )

    sns.scatterplot(
        x=df2.index,
        y=y,
        hue=category_col,
        data=df2,
        ax=axes[1],
        palette=palette,
        s=marker_size,
    )

    for axs in axes:
        axs.set_ylabel(y_label)
        axs.set_xlabel("Year")
        axs.legend().remove()

    axes[0].set_title("Including Uncertains")
    axes[0].title.set_position([0.5, 1.05])  # adjust the position of the title

    axes[1].set_title("Excluding Uncertains")
    axes[1].title.set_position([0.5, 1.05])  # adjust the position of the title

    if not show_legend:
        fig.legend().remove()
    else:
        handles, labels = axes[0].get_legend_handles_labels()
        fig.legend(
            handles,
            labels,
            loc="lower center",
            ncol=legend_ncols,
            frameon=False,
            bbox_to_anchor=(0.5, -0.1),
        )  # adjust the position of the legend

    plt.subplots_adjust(bottom=0.2)

    plt.show()


def plot_heatmap(data, title):
    fig, ax = plt.subplots(1, 1)
    ax = sns.heatmap(
        data, annot=True, cmap="Blues", fmt="g", cbar=False, annot_kws={"fontsize": 10}
    )
    ax.set(title=title, ylabel=None, xlabel=None)
    ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha="right")

    plt.show()


def prepare_heatmap_data(df, index_col, cols_col, values_col, ascending=False):
    """
    Prepare data for a heatmap visualization by pivoting and sorting a dataframe.

    Args:
    - df: input dataframe
    - index_col: column name for the index of the pivoted dataframe
    - cols_col: column name for the columns of the pivoted dataframe
    - values_col: column name for the values of the pivoted dataframe
    - ascending: boolean to specify whether to sort in ascending or descending order (default: False)

    Returns:
    - pivoted and sorted dataframe
    """
    # Pivot the data to create a matrix
    matrix = df.pivot(index=index_col, columns=cols_col, values=values_col)

    # Sort the matrix by descending order of values in the column with the highest value
    highest_col = matrix.idxmax(axis=1).values[0]
    matrix = matrix.sort_values(highest_col, ascending=ascending)

    return matrix


```

## Bioeconomy Demarkations {.smaller}

::::{.columns}

:::{.column width="50%"}
**Using producer / user codes
**

|SNI Code | Description                            |
|--------:|:---------------------------------------|
|02       | Forestry and related services
|20       | Wood and wood product manufacturing except furniture
|21       | Pulp, paper and paper product manufacturing
|36       | Furniture manufacturing; other manufacturing
:::

:::{.column width="50%"}
**Adding keywords of value chain**

    - "virke",
    - "cellulos",
    - "lignin",
    - "spån", 
    - "bark",
    - "levulinsyra" (Levulinic acid),
    - "furfural" (Furfural),
    - "svarttjära",
    - "svartlut",
    - "växtbas",
    - "ved",
    - "trä",
    - "skog",
    - "papper",
    - "biobränsle",
    - "biologiskt",
    - "nedbrytbar",
    - "papper",
    - "pappret",
    - "karton",
    - "tencel",
:::

::::

## First Estimation of Forest Bioeconomy Innovativeness 

```{python}

bioeconomy = pd.read_sql(
    """
select
  i.sinno_id,
  i.innovation_name_in_swedish AS name,
  i.description_in_swedish AS description,
  i.additional_information_if_origin_new_scientific_discovery || i.additional_information_if_origin_new_technologies_or_materials || i.additional_info_if_origin_official_regulation_legislation_and_standards || i.additional_information_if_origin_solution_for_a_problem || i.additional_information_if_origin_performance || i.additional_information_if_origin_other AS info,
  i.year_of_commercialization AS year,
  us.use_sector
from
  innovation i
  join use_sectors us on i.sinno_id = us.sinno_id
where
  (
    us.use_sector like '02%'
    or us.use_sector like '20%'
    or us.use_sector like '21%'
    or us.use_sector like '36%'
    or product_code like '02%'
    or product_code like '20%'
    or product_code like '21%'
    or product_code like '36%'
  )
  or (
    description like '%virke%'
    or description like '%cellulos%'
    or description like '%lignin%'
    or description like '%spån%'
    or description like '%bark%'
    or description like '%levulinsyra%'
    or description like '%furfural%'
    or description like '%svarttjära%'
    or description like '%svartlut%'
    or description like '%växtbas%'
    or description like '%ved%'
    or description like '%trä%'
    or description like '%skog%'
    or description like '%biobränsle%'
    or description like '%biologisk%'
    or description like '%nedbrytbar%'
    or description like '%papper%'
    or description like '%pappret%'
    or description like '%karton%'
    or description like '%tencel%'
  );
""",
    swinno_db,
)

sni_codes = pd.read_sql_query(
    """
select
*
from 
sni_codes
""",
    swinno_db,
)

sni_codes = sni_codes.rename(columns={"code": "use_sector"})

swinno = pd.read_sql_query(
    """
select sinno_id, year_of_commercialization as year, innovation_name_in_swedish as name
from innovation;
""",
    swinno_db,
)

swinno["bioeconomy"] = swinno["sinno_id"].isin(bioeconomy["sinno_id"].unique())


def plot_innovation_counts_by_sector(df, title):
    df = df.copy()
    df["sector"] = df["use_sector"].astype(str).str[:2]
    df = (
        df.groupby("sector")
        .nunique()["sinno_id"]
        .sort_values(ascending=False)
        .reset_index()
    )
    df = df.rename(columns={"sinno_id": "count"})
    df = df.join(sni_codes.set_index("use_sector"), on="sector", how="left")
    df = df[["count", "sector", "label"]]

    chart = (
        alt.Chart(df)
        .mark_bar()
        .encode(
            x=alt.X("count:Q", title="Number of innovations"),
            y=alt.Y("label:N", title="Sector", sort="-x"),
            tooltip=["count"],
        )
        .properties(title=title, height=700)
    )

    return chart


plot_innovation_counts_by_sector(bioeconomy, "Innovation counts by sector in SWINNO")


```

# Trend

```{python}
# | label: plot bioeconomy share
def calculate_bioeconomy_share(df):
    df = df.copy()
    df = df[["sinno_id", "year", "bioeconomy"]]
    df = (
        df.groupby("year")
        .agg(
            total_count=("sinno_id", "nunique"), bioeconomy_count=("bioeconomy", "sum")
        )
        .reset_index()
    )
    df["bioeconomy_share"] = df["bioeconomy_count"] / df["total_count"]

    return df


def plot_innovation_counts_by_year(df, title):
    df = calculate_bioeconomy_share(df)

    base = alt.Chart(df).encode(alt.X("year:O", axis=alt.Axis(title="Year")))

    count = (
        base.mark_line(color="red", opacity=0.6)
        .encode(
            alt.Y("bioeconomy_count:Q", title="Count of Bioeconomy Innovations"),
            tooltip=["bioeconomy_count", "bioeconomy_share", "year"],
        )
        .interactive()
    )

    share = (
        base.mark_line()
        .encode(
            alt.Y("bioeconomy_share:Q", title="Share of Bioeconomy Innovations"),
            tooltip=["bioeconomy_count", "bioeconomy_share", "year"],
        )
        .interactive()
    )

    chart = (
        alt.layer(count, share)
        .resolve_scale(y="independent")
        .properties(title=title, width=900)
        .configure_title(font="Inconsolata")
        .configure_axis(labelFont="Inconsolata", titleFont="Inconsolata")
    )

    return chart


plot_innovation_counts_by_year(swinno, "Innovation counts by year in SWINNO")
```


# Three Visions for a Bioeconomy

:::: columns
::: {.column width="33%"}
![Bio-Technology Vision](../assets/Biotech.jpg){.fragment}
:::

::: {.column width="33%"}
![Bio-Resource Vision](../assets/Bioresource.jpg){.fragment}
:::

::: {.column width="33%"}
![Bio-Ecology Vision](../assets/Bioecology.jpg){.fragment}
:::
::::

[@bugge2016WhatBioeconomyReview]{.slide-cite style="font-size: x-small"}

## Bioeconomy Vision Classification{.smaller}


| @bugge2016WhatBioeconomyReview | Biotechnology | Bioresource | Bioecology |
|---|---|---|---|
| Aim &   Objectives | Economic growth & job   creation | Economic growth &   sustainability | Sustainability, biodiversity,   conservation of ecosystems, avoiding soil degradation |
| Value   Creation | Application of biotechnology,   commercialisation of research & technology | Conversion and upgrading of   bio-resources (process oriented) | Development of integrated   production systems and high-quality products with territorial identity |
| Drivers   & mediators of innovation | R & D, patents, TTOs,   Research councils and funders (Science push, linear model) | Interdisciplinary, optimisation   of land use, include degraded land in the production of biofuels, use and   availability of bio-resources, waste management, engineering, science &   market (Interactive & networked production mode) | Identification of favourable   organic agro-ecological practices, ethics, risk, transdisciplinary   sustainability, ecological interactions, re-use & recycling of waste,   land use, (Circular and self-sustained production mode) |

| @vivien2019HijackingBioeconomy | Type II | Type III | Type I |
|---|---|---|---|
|  | A science-based economy driven   by industrial biotechnology<br>     <br>     The cell is a factory | Biomass replaces fossil fuels   and mining to produce energy and materials<br>     <br>     Biorefining at the heart of ecological transition (multilevel perspective). | An ecological economy, that is   compatible with the biosphere<br>     <br>     Counter-expertise rather than concrete technical solutions Criticism from   social groups who remain at the margins of decisionmaking centers |
| Codes | 1 | 2 | 3 |


## Preliminary Results

```{python}
bv_df = pd.read_sql(
    """SELECT bv.sinno_id, bv.bioeconomy_vision, i.year_of_commercialization AS "i.year"
FROM bioeconomy_visions AS bv
JOIN innovation AS i ON i.sinno_id = bv.sinno_id
WHERE bv.sinno_id NOT IN (SELECT sinno_id FROM categorization_notes WHERE notes NOT LIKE "%not forest%");
""",
    swinno_db,
)
```


```{python}

display(
    Markdown(
        f"<span style='font-size:10rem'>{bv_df.loc[:, 'sinno_id'].nunique()}</span> unique forest bioeconomy innovations classified"
    )
)

```

## More

```{python}
ei_count = pd.read_sql(
    """
SELECT
  codes.Category AS Type,
  COUNT(ei.innovation_type) AS Count
FROM
  eco_innovations as ei
  JOIN [classification_codes] AS codes ON codes.code = ei.innovation_type
WHERE ei.sinno_id NOT IN (SELECT sinno_id FROM categorization_notes WHERE notes NOT LIKE "%not forest%")
GROUP BY
  innovation_type
ORDER BY
  Count DESC;
""",
    swinno_db,
)

ei_count_0 = pd.read_sql(
    """
SELECT
  codes.Category AS Type,
  COUNT(ei.innovation_type) AS Count
FROM
  eco_innovations as ei
  JOIN [classification_codes] AS codes ON codes.code = ei.innovation_type
WHERE
  NOT EXISTS(
    SELECT * 
    FROM
      eco_innovations AS ei2
    WHERE
      ei2.sinno_id = ei.sinno_id
      AND ei2.innovation_type = "000"
  )
AND ei.sinno_id NOT IN (SELECT sinno_id FROM categorization_notes WHERE notes NOT LIKE "%not forest%")
GROUP BY
  Type
ORDER BY
  Count DESC;
""",
    swinno_db,
)

bv_count = pd.read_sql(
    """
SELECT
  codes.Category AS Vision,
  COUNT(bioeconomy_vision) AS Count
FROM
  bioeconomy_visions
  JOIN [classification_codes] AS codes ON codes.code = bioeconomy_visions.bioeconomy_vision
WHERE
  bioeconomy_visions.sinno_id NOT IN (
    SELECT
      sinno_id
    FROM
      categorization_notes
    WHERE
      notes NOT LIKE "%not forest%"
  )
GROUP BY
  Vision
ORDER BY
  Count DESC;
   """,
    swinno_db,
)

bv_count_zero = pd.read_sql(
    """
SELECT
  codes.Category AS Vision,
  COUNT(bioeconomy_vision) AS Count
FROM
  bioeconomy_visions
  JOIN [classification_codes] AS codes ON codes.code = bioeconomy_visions.bioeconomy_vision
WHERE
  NOT EXISTS (
    SELECT
      *
    FROM
      bioeconomy_visions AS bv2
    WHERE
      bv2.sinno_id = bioeconomy_visions.sinno_id
      AND bv2.bioeconomy_vision = 0
  )
  AND bioeconomy_visions.sinno_id NOT IN (
    SELECT
      sinno_id
    FROM
      categorization_notes
    WHERE
      notes NOT LIKE "%not forest%"
  )
GROUP BY
  Vision
ORDER BY
  Count DESC;
""",
    swinno_db,
)
```


## Count of Bioeconomy Visions
```{python}
bv_counts = pd.merge(bv_count, bv_count_zero, on="Vision", how="left")

bv_counts.columns = ["Vision", "Count", "Count Excl. Unsure"]
bv_counts.loc[:, "Count Excl. Unsure"] = (
    bv_counts["Count Excl. Unsure"].fillna(0).astype(int)
)

bv_counts.style.set_properties(**{"text-align": "right"}).hide_index()

```

## Count of Eco-Innovations

```{python}
# | label: tbl-ei-article-count
# | tbl-cap: Count of Eco-Innovations Using Swinno Data

ei_counts = pd.merge(ei_count, ei_count_0, on="Type", how="left")

ei_counts.columns = ["Type", "Count", "Count Excl. Unsure"]
ei_counts.loc[:, "Count Excl. Unsure"] = (
    ei_counts["Count Excl. Unsure"].fillna(0).astype(int)
)

ei_counts.style.set_properties(**{"text-align": "right"}).hide_index()
```

## Bioeconomy Vision Heatmap

```{python}
# | label: fig-bva-sectors
# | fig-cap: Heatmap of Bioeconomy Visions by Sector


bv_sectors = pd.read_sql(
    """
SELECT
  c.Category AS vision,
  sni_codes.label AS sector,
  count(bv.bioeconomy_vision) AS count
FROM
  bioeconomy_visions AS bv
  join use_sectors ON bv.sinno_id = use_sectors.[sinno_id]
  join sni_codes ON SUBSTR(use_sectors.use_sector, 1, 2) = sni_codes.code
  join [classification_codes] AS c ON bv.bioeconomy_vision = c.Code
WHERE
  NOT EXISTS(
    SELECT
      *
    FROM
      bioeconomy_visions AS bv2
    WHERE
      bv2.sinno_id = bv.sinno_id
      AND bv2.bioeconomy_vision = 0
  )
  AND bv.sinno_id NOT IN (
    SELECT
      sinno_id
    FROM
      categorization_notes
    WHERE
      notes NOT LIKE "%not forest%"
  )
GROUP BY
  sector,
  bioeconomy_vision;
""",
    swinno_db,
)

bv_matrix = prepare_heatmap_data(
    bv_sectors, index_col="sector", cols_col="vision", values_col="count"
)

plot_heatmap(bv_matrix, "Count Bioeconomy Vision by Sector Excluding Uncertains")
```

## Examples 

<!---7495001 	good example of both bv2 and bv3 because of high integration of production system and conversion and upgrading of resource

7428001 	good example for innovation which could go either way

9048001 	good bv 2 example, good example of bv1
  
--->

## Uncertain Cases 


```{python}
uncertains = pd.read_sql(
    """
SELECT
DISTINCT
  i.sinno_id,
  i.innovation_name_in_swedish AS name,
  i.description_in_swedish AS description,
  i.additional_information_if_origin_new_scientific_discovery || i.additional_information_if_origin_new_technologies_or_materials || i.additional_info_if_origin_official_regulation_legislation_and_standards || i.additional_information_if_origin_solution_for_a_problem || i.additional_information_if_origin_performance || i.additional_information_if_origin_other AS info,
  i.year_of_commercialization AS year
FROM
  innovation i
  JOIN use_sectors us ON i.sinno_id = us.sinno_id
  JOIN bioeconomy_visions bv on i.sinno_id = bv.sinno_id
WHERE i.sinno_id in (select distinct sinno_id from bioeconomy_visions where bioeconomy_vision = "0");
""",
    swinno_db,
)

display(Markdown(f"{uncertain["sinno_id"].nunique()} cases are marked as unsure bioeconomy visions."))
```